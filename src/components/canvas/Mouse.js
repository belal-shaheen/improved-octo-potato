/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: cloudstorm (https://sketchfab.com/cloudstormchnl)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/macintosh-mouse-a37ff50ef0f94fae9f1dc20b1f2f5b5f
title: Macintosh Mouse
*/

import React, { useRef,useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { Canvas, useThree, useFrame } from "react-three-fiber"
import { useDrag } from "react-use-gesture"
import { useSpring } from "@react-spring/core";
import { a } from "@react-spring/three";
import { useEffect } from 'react'

// function Paddle({ args = [2, 0.5, 1] }) {
//   const [ref, api] = useBox(() => ({ args }))

//   useFrame((state) => {
//     api.position.set(
//       (state.mouse.x * state.viewport.width) / 2,
//       -state.viewport.height / 2,
//       0
//     )
//     api.rotation.set(0, 0, state.mouse.x)
//   })

//   return (
//     <mesh ref={ref}>
//       <boxBufferGeometry args={args} />
//       <meshStandardMaterial color='lightblue' />
//     </mesh>
//   )
// }

export default function Model(props) {
  const group = useRef()
  const { nodes, materials } = useGLTF('mouse.gltf')
  const { size, viewport } = useThree();
  const [position, setPosition] = useState([0, 0, 0]);
  const aspect = size.width / viewport.width;
  const [active, setActive] = useState(0);

  const bind = useDrag(({ offset: [x, y] }) => {
    const [,, z] = position;
    setPosition([Math.min(Math.max(x / aspect, -0.8), 1), 0, Math.min(Math.max(y / aspect, -0.8), 1)]);
}, { pointerEvents: true });

  const { spring } = useSpring({
    spring: active,
    config: { mass: 5, tension: 400, friction: 50, precision: 0.0001 },
  });
  const [hovered, setHover] = useState(false)
  const posz = spring.to([0, 4], [1, -4]);
  let keyPressed = useKeyPress("n")

  useEffect(() => {
    if(keyPressed && hovered) {
      setActive(Number(!active))
    }
  }, [keyPressed, hovered])

  return (
    <mesh position={position}  {...bind()}>
    <group ref={group} {...props} dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group
            position={[0, 70.16, -5.84]}
            rotation={[-1.62, 0, -Math.PI / 2]}
            scale={[205.47, 148.43, 107.98]}
          >
            <mesh
              geometry={nodes.main_Material_0.geometry}
              material={nodes.main_Material_0.material}
            />
          </group>
          <group
            position={[0, 124, -115.83]}
            rotation={[-1.52, 0, 0]}
            scale={[91.11, 64.7, 8.98]}
            >
            <a.mesh
              onClick={() => setActive(Number(!active))}
              onPointerOver={(e) => setHover(true)}
              onPointerOut={(e) => setHover(false)}
              position-z={posz}
              geometry={nodes.button_Material001_0.geometry}
              material={nodes.button_Material001_0.material}
            />
          </group>
          <group
            position={[79.61, 7.43, -158.22]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[6.28, 6.28, 6.28]}
          >
            <mesh
              geometry={nodes.rubber_Material_0.geometry}
              material={nodes.rubber_Material_0.material}
            />
          </group>
          <group
            position={[-79.19, 7.43, -158.22]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[6.28, 6.28, 6.28]}
          >
            <mesh
              geometry={nodes.rubber001_Material_0.geometry}
              material={nodes.rubber001_Material_0.material}
            />
          </group>
          <group
            position={[-0.18, 10.01, 53.79]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[90.67, 87.09, 86.19]}
          >
            <mesh
              geometry={nodes.Circle_Material004_0.geometry}
              material={materials['Material.004']}
            />
          </group>
          <group
            position={[-77.89, 113.89, 95.86]}
            rotation={[-1.47, 0, 0]}
            scale={[16.66, 16.66, 63.95]}
          >
            <mesh
              geometry={nodes.BezierCurve_Material_0.geometry}
              material={nodes.BezierCurve_Material_0.material}
            />
          </group>
          <group
            position={[-15.14, 42.02, -390.37]}
            rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
            scale={[100, 100, 100]}
          >
            <mesh
              geometry={nodes.cable_Material002_0.geometry}
              material={materials['Material.002']}
            />
          </group>
          <group
            position={[0, 42, -210.75]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[28.1, 3.6, 20.81]}
          >
            <mesh
              geometry={nodes.Cube001_Material001_0.geometry}
              material={nodes.Cube001_Material001_0.material}
            />
          </group>
          <group
            position={[0, 41.85, -228.97]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[18.16, 2.54, 13.36]}
          >
            <mesh
              geometry={nodes.Cube_Material001_0.geometry}
              material={nodes.Cube_Material001_0.material}
            />
          </group>
          <group
            position={[0, 41.85, -235.68]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[15.52, 2.54, 11.42]}
          >
            <mesh
              geometry={nodes.Cube002_Material001_0.geometry}
              material={nodes.Cube002_Material001_0.material}
            />
          </group>
          <group
            position={[0, 41.85, -242.55]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[13.13, 2.54, 9.52]}
          >
            <mesh
              geometry={nodes.Cube003_Material001_0.geometry}
              material={nodes.Cube003_Material001_0.material}
            />
          </group>
          <group
            position={[-0.26, 46.04, 53.74]}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={43.85}
          >
            <mesh
              geometry={nodes.Sphere_Material003_0.geometry}
              material={materials['Material.003']}
            />
          </group>
        </group>
      </group>
    </group></mesh>
  )
}

useGLTF.preload('/mouse.gltf')

function useKeyPress(targetKey) {
  // State for keeping track of whether key is pressed
  const [keyPressed, setKeyPressed] = useState(false);
  // If pressed key is our target key then set to true
  function downHandler({ key }) {
    if (key === targetKey) {
      setKeyPressed(true);
    }
  }
  // If released key is our target key then set to false
  const upHandler = ({ key }) => {
    if (key === targetKey) {
      setKeyPressed(false);
    }
  };
  // Add event listeners
  useEffect(() => {
    window.addEventListener("keydown", downHandler);
    window.addEventListener("keyup", upHandler);
    // Remove event listeners on cleanup
    return () => {
      window.removeEventListener("keydown", downHandler);
      window.removeEventListener("keyup", upHandler);
    };
  }, []); // Empty array ensures that effect is only run on mount and unmount
  return keyPressed;
}
